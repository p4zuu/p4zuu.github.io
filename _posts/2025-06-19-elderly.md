---
layout: post
title: elderly - m0lecon CTF 2025 Teaser (Writeup)
date: 2025-06-19
comment: false
---

I finnaly managed to solve a chall I didn't manage to solve during the m0lecon
Teaser CTF. It was an amazing journey of messing with page table entries,
aarch64 shellcoding and escaping nsjail, only with one bit flip.

# Challenge overview

It's a simple aarch64 Linux kernel module with the following interesting ioctl:

```c
static long pwn_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
    struct params p;
    int ret = -EINVAL;
    void *ptr = NULL;

    if (copy_from_user(&p, (void *)arg, sizeof(p)))
        return ret;

    if (!p.size || (p.size > 192))
        return ret;

    mutex_lock(&g_mutex);
    if (!done) {
        ptr = kmalloc(p.size, p.account ? GFP_KERNEL_ACCOUNT : GFP_KERNEL);
        if (!ptr)
            goto err;

        u64 page = (u64)ptr & ~0xfffUL;
        u64 pval = (u64)ptr + (p.idx / 8);
        if ((pval & ~0xfffUL) != page)
            goto err;

        change_bit(p.idx, ptr);

        done = 1;
    }

    ptr = NULL;
    ret = 0;
err:
    if (ptr)
        kfree(ptr);
    mutex_unlock(&g_mutex);
    return ret;
}
```

In short, we can ask the module for a heap allocation of size below or equal to
192, and we also control the allocation flags. Then, we can flip a bit in the
same page where our chunk was allocated (`change_bit()` is not bound-checked).
All of that only once, and in the same shot. Pretty low primitive. Also, our
welcome shell runs inside nsjail.

# Solution

My solution consists in getting arbitrary physical memory read/write by messing
with the page tables. With this we can bruteforce the kernel text base address,
and write a shellcode in a syscall handler that when executed will escape our
task from the sandbox and also getting root. The idea to get arb physical memory
read/write is to flip a victim `pipe_buffer->page` bit to make it point to
another valid page, that we'll free afterwrads to get a sort of `struct page`
uaf. Then, we spray page tables to get out victim `pipe_buffer->page` being
reallocated to a level 2 page table. With this, we should be able to overwrite
page table entries by writing to our victim pipe and to get arb physical memory
read/write by writing a fake page table entry pointing to the physical address
we want.

Please find the full exploit
[here](https://github.com/p4zuu/ctf/tree/main/2025-m0lecon-teaser/pwn_elderly/pwn).

Here is more detailed workthrough:

1. Gaining physical memory arbitrary read and write
   1. Spray some
      [pipe_buffer](https://elixir.bootlin.com/linux/v6.15.2/source/include/linux/pipe_fs_i.h#L26)
      in kmalloc-cg-192 cache. We can do that by simply allocating pipes (so by
      calling `pipe()`). However, the default pipe (internally
      [pipe_inode_info](https://elixir.bootlin.com/linux/v6.15.2/source/include/linux/pipe_fs_i.h#L86)
      allocates 0x10 pipe buffers
      ([code](https://elixir.bootlin.com/linux/v6.15.2/source/fs/pipe.c#L816)),
      leading to `pipe->bufs` allocated in kmalloc-cg-1024 (0x10 * sizeof(struct
      pipe_buffer) = 640). To make the pipe buffers in kmalloc_cg-192, we can
      use the `F_SETPIPE_SZ` `fcntl` to change the number of internal buffers,
      reducing the size of `pipe->bufs`
      ([code](https://elixir.bootlin.com/linux/v6.15.2/source/fs/pipe.c#L1361)).
   2. Free 1 pipe buffer out of two, to make room for our future chunk allocated
      in the module.
   3. Allocate a chunk in kmalloc-cg-192 with the module ioctl, and flip the 6th
      bit of the next chunk. Here, we hope that our chunk is adjacent to a
      `pipe_buffer`, and we want to flip a bit in this adjacent `pipe_buffer`
      `page` field. Since `page`s are allocated in a contiguous memory region,
      we know that &victim_page + sizeof(struct page) points to another valid
      page. Furthermore, `sizeof(struct page) = 1 << 6`. The goal of this is
      that the flipped `page` address points to one of the sprayed pipe's
      `pipe_buffer->page`. With this, we'll have somehwere a victim pipe
      pointing to another pipe's buffer.
   4. Look for the victim pipe: we can simply read to all sprayed pipes, and
      check if the value we read is the same we initialized the pipe with. If it
      doesn't match, it means that this pipe's buffer point to another buffer.
      We successfuly flipped a `pipe_buffer->page` to another valid page.
   5. Free all pipes except our victim pipe. With this, our victim's pipe buffer
      is now backed by a freed page.
   6. Spray page tables by writing to `mmap()` regions in userspace (mapped at
      the beginning of the exploit). This will trigger a #PF, handled by the
      kernel by allocating new page tables. If the spray worked, we have our
      pipe buffer pointing to a level 2 page table (page tables are page-sized),
      containing page table entries. We can confirm that by writing a fake page
      table entry in our victim pipe, pointing to the physical address
      `0x40000000`. Now we can read to all mmap'ed regions and if for one, the
      read value is not the one we wrote when initilizaing the region, we know
      that we messed with the page table, and the address translation points to
      `0x40000000` physical address.
   7. Now that we have a our victim pipe and our victim page (the mapped region
      pointing to somewhere else), we can get arb read/write by writing a fake
      page table entry in the victim pipe buffer to the physical address we
      want, and reading/writing to it by the simply reading/writing to the
      victim page region (ie. simply `memcpy` to the address of the victim page,
      returned by `mmap`).

2. Finding the kernel base physical address by bruteforcing read to all pages
   start and check if the read value matches the 8 first bytes of the kernel
   .text.

3. Write our shellcode at `do_symlinkat()` address, which is called when
   creating a symlink. It's accessible within the sandbox. I stole this
   technique [here](https://ptr-yudai.hatenablog.com/entry/2023/12/08/093606). I
   also stole the shellcode we're writing and adapted it to aarch64. It does the
   following:

```
commit_creds(init_cred);
task = find_task_by_vpid(1);
switch_task_namespaces(task, init_nsproxy);
new_fs = copy_fs_struct(init_fs);
current_task = find_task_by_vpid(getpid());
current_task->fs = new_fs;
```

With this, we're able to get root, get unrestricted namespaces and use the
unsandboxed init_fs, giving full nsjail esapce.

We can now execute the shellcode by creating a symlink and profit.

```bash
===============================================================
=============== The gets() of kernel pwn challs ===============
===============================================================
sh: can't access tty; job control turned off
~ $ /jail/exploit
[+] Victim pipe found: 19
[+] Found victim sprayed page: 0xdfa00000
[+] Looking for kernel physical base address...
[+] Kernel physical base: 0xb5010000
[+] pid: 2
[+] Writing shellcode
[+] Triggering
sh: can't access tty; job control turned off
/ # id
uid=0(root) gid=0(root)
/ # cat /dev/vda
t  ����S�-�
           8�q��ۻ�B%Y1/tmp/flag_ڋ�ZP�,
                                      -�        t`
                                                  -�-�-��������  tktk��-�0-�-�-� -�A�������� �(2�(2�(2-�(������� tktk�.��tk
   .
    ..
      flag.txt

              .�..ptm{XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}
```

# Limitations

Unfortunately the exploit is not reliable. The pipe spray is not very effective,
for whatever reason. It struggles allocating a pipe_buffer next to our chunk
allocated by the module. If this succeeds, the rest is reliable, but this step
is not. :(
